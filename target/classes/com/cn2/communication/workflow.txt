Workflow of a Chat and VoIP App
A chat and VoIP application has two main functions:

Text communication: Send and receive text messages.
Voice communication: Stream and receive audio data in real-time.
To efficiently handle these, the app uses UDP sockets for communication and multithreading to manage different tasks simultaneously.

Sockets
Datagram Socket (1 socket per peer):
A single UDP socket is sufficient for both text and voice communication as it can handle packets for multiple purposes (e.g., text, call signals, audio).
The app can differentiate the packet types by adding a small header or prefix in the data payload to distinguish between text, control messages (like CALL_REQUEST), and audio packets.
Threads
A chat and VoIP app typically needs four main threads to manage its operations effectively:

1. Receiver Thread
Purpose: Listens on the UDP socket for incoming packets.
Responsibilities:
Read incoming packets from the socket.
Distinguish between text messages, control signals (CALL_REQUEST, CALL_ACCEPT, etc.), and voice data using a simple header or flag in the packets.
Handle text messages by updating the UI or saving logs.
Handle control signals for managing call states.
Forward audio packets to the playback mechanism.
Implementation: Runs in an infinite loop to listen for and process all incoming packets.

2. Message Sender Thread
Purpose: Sends text messages over the UDP socket.
Responsibilities:
Wait for input from the user (e.g., pressing the "Send" button).
Encapsulate the text message in a packet and send it to the peer.
Implementation: Triggered only when a user sends a message.

3. Voice Sender Thread
Purpose: Captures microphone input and streams audio data to the peer.
Responsibilities:
Use a TargetDataLine to capture audio from the microphone.
Convert audio data into byte arrays and send them as packets over the UDP socket.
Ensure real-time streaming by maintaining low latency and efficient buffer management.
Implementation: Active only during a call and stops when the call ends.

4. Voice Receiver & Playback Thread
Purpose: Decodes and plays incoming audio data.
Responsibilities:
Continuously listen for audio packets from the Receiver Thread.
Use a SourceDataLine to play the audio in real-time.
Handle network jitter by buffering or smoothing incoming packets.
Implementation: Active only during a call.

Thread-Socket Mapping

Thread	                    Socket Used	                    Task
Receiver Thread	            Shared UDP socket	            Receives all packets (text, control, audio) from the peer.
Message Sender Thread	    Shared UDP socket	            Sends text messages to the peer.
Voice Sender Thread	        Shared UDP socket	            Streams captured audio data to the peer during a call.
Voice Playback Thread	    Shared UDP socket	            Decodes and plays incoming audio packets during a call.

Workflow

Initialization:

Create a single UDP socket and bind it to the local port.
Start the Receiver Thread to listen for incoming packets.

Text Messaging:

User inputs a message.
Message Sender Thread sends the message as a UDP packet.
The Receiver Thread on the peer's side processes the packet and updates their UI.

Call Setup:

User clicks "Call", and the Message Sender Thread sends a CALL_REQUEST message.
The receiver's Receiver Thread detects the CALL_REQUEST and prompts the user to accept/reject.
If accepted, both peers exchange a CALL_ACCEPT signal, activating their Voice Sender Thread and Voice Playback Thread.

Voice Communication:

The Voice Sender Thread captures audio, encodes it, and sends it to the peer as UDP packets.
The Voice Playback Thread decodes and plays incoming audio packets.

Call Termination:

Either peer sends a CALL_END message.
Both peers terminate their Voice Sender and Voice Playback threads.

Exit:

On application exit, all threads are gracefully stopped, and the socket is closed.

Summary of Components
Single UDP Socket: Manages all communication (text, call signals, audio).

Four Threads:
Receiver Thread: Handles all incoming packets.
Message Sender Thread: Sends text messages.
Voice Sender Thread: Streams audio.
Voice Playback Thread: Plays received audio.

Thread Lifetimes:
Receiver Thread: Always running.
Message Sender Thread: Triggered as needed.
Voice Sender Thread & Voice Playback Thread: Active only during calls.

This design ensures simplicity, scalability, and efficient use of system resources.

App Class
The main application acts as the control center:

Variables:

Shared DatagramSocket: For communication.
Peer Info: Stores the peer’s IP address and port.
Thread Instances: References for ReceiverThread, MessageSenderThread, and VoiceSenderThread.
Call State: Tracks if the app is in an active call.
Responsibilities:

Initializes the GUI for chat and call controls.
Manages thread lifecycles:
Starts the ReceiverThread at app launch.
Starts/stops VoiceSenderThread when a call is accepted/ended.
Handles user actions:
Sends chat messages via MessageSenderThread.
Sends call control messages (CALL_REQUEST, CALL_ACCEPT, etc.).
Implements handlers for incoming data:
Displays messages in the chat area.
Plays audio data during calls.
Workflow
Chat:

User enters a message.
MessageSenderThread sends the message as a packet.
Peer’s ReceiverThread receives the packet and displays the message.
Call Initiation:

User clicks "Call" button:
Sends CALL_REQUEST via MessageSenderThread.
Peer receives the request and responds with CALL_ACCEPT or CALL_REJECT.
Active Call:

Both peers start their VoiceSenderThread to send and receive voice data.
Call Termination:

User ends the call:
Sends CALL_END via MessageSenderThread.
Stops VoiceSenderThread.
Peer receives the message and stops their VoiceSenderThread.
This structure ensures modularity, clarity, and effective communication management.